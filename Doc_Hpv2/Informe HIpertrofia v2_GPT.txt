1. ¿Los principios de la metodología están aplicados? (visión global)

Bloque de adaptación inicial:
La lógica de la fase de adaptación del PDF está implementada en backend (create_adaptation_block_tables.sql, backend/routes/adaptationBlock.js) y expuesta vía /api/adaptation/*.
En frontend ya hay integración específica dentro de HipertrofiaV2ManualCard.jsx (carga de progreso, selección de bloque y transición). No parece “muerto en código”; el flujo existe pero está menos maduro que el D1‑D5.
Bloque de hipertrofia principiante (freq 2, D1‑D5):
La estructura semanal, volumen por músculo, mezcla Multi/Uni/Analítico, RIR objetivo 2‑3 y lógica de +2,5 % / deload están reflejadas en:
Tabla hipertrofia_v2_session_config (config D1‑D5).
Selección de ejercicios en backend/routes/hipertrofiaV2.js (se respetan tipos y orden: multi → uni → analítico).
Script backend/scripts/validate-volume-distribution.js valida los rangos de series por músculo exactamente como en el PDF de “Volumen de Entrenamiento”.
Módulos de progresión, deload, prioridad y solapamiento neural (apply_microcycle_progression, check_deload_trigger, activate_deload, detect_neural_overlap, etc.) conectados por rutas /apply-progression, /check-deload, /activate-deload, /check-neural-overlap, /apply-fatigue-adjustments, etc.
Flags de fatiga + solapamiento neural + transición entre bloques:
Existen tablas fatigue_flags, hypertrophy_set_logs, hypertrophy_progression y funciones SQL para detección automática de fatiga y ajustes de carga.
Las rutas de fatiga (/report-fatigue, /fatigue-status, /detect-auto-fatigue, /apply-fatigue-adjustments, /fatigue-history) y de solapamiento neural (/check-neural-overlap) representan bien la lógica del documento de “Flags de fatiga / solapamiento / deload”.
RIR y educación del usuario:
El uso de RIR por serie está soportado (save-set, update-progression) y el modal de referencia RIR (RIRReferenceModal.jsx) refleja la tabla teórica de zonas RIR 0–4+.
Conclusión rápida:
Los pilares “duros” de la metodología de Hipertrofia v2 (estructura D1‑D5, volumen, mezcla multi/uni/analítico, RIR 2‑3, progresión +2,5 %, deload, flags de fatiga y solapamiento neural, transición adaptación→hipertrofia) sí están plasmados en el backend y en buena parte en el frontend. Lo que falta son detalles de acabado y algunas extensiones de la teoría (duración 10–12 semanas, series de aproximación, ajustes por sexo, etc.).

2. Cómo evoluciona hoy un principiante en la app (teoría vs código)

Evaluación inicial y nivel
Teoría: distinguir principiante / intermedio / avanzado y grupos prioritarios.
Código: HipertrofiaV2ManualCard.jsx llama a /api/hipertrofia-specialist/evaluate-profile que usa el prompt hipertrofia_specialist.md para devolver recommended_level + suggested_focus_areas.
Uso en app: de ahí sale el nivel (normalmente “Principiante”) que se pasa al motor D1‑D5 y al catálogo de ejercicios.
Bloque de adaptación (si es principiante “absoluto”)
Teoría (Bloque de Adaptación Inicial + flags de transición):
Full Body / Half Body 1–3 semanas, 4–5 días/semana.
RIR objetivo 3–4, descansos más cortos, foco motor.
Transición a hipertrofia cuando se cumplen 4 criterios (adherencia ≥80 %, RIR medio ≤4, técnica estable, progreso de carga ≥8 %).
Código:
Tablas app.adaptation_blocks, app.adaptation_criteria_tracking, app.adaptation_technique_flags + vista adaptation_progress_summary.
Funciones evaluate_adaptation_completion y transition_to_hypertrophy.
Endpoints /api/adaptation/generate, /progress, /evaluate-week, /evaluate, /transition, /technique-flag.
En HipertrofiaV2ManualCard.jsx ya se muestran:
Badges de progreso (AdaptationTrackingBadge).
Modal de selección de bloque (AdaptationBlockSelection).
Modal de transición (AdaptationTransitionModal) que, al confirmar, llama a /api/adaptation/transition y después genera el plan D1‑D5.
Coherencia: a nivel de lógica y datos sí replica muy bien la teoría; la UX todavía puede pulirse (ver recomendaciones).
Generación del bloque de hipertrofia D1‑D5
Teoría:
Frecuencia 2 por músculo / semana, 5 días de entreno, volumen por grupo según tablas.
Días 1–3 ≈80 % 1RM, días 4–5 ≈70–75 %, RIR 2–3.
Multi → Uni → Analítico.
Bloque de 10–12 semanas + semana 0 de calibración.
Código:
Frontend llama a /api/hipertrofiav2/generate-d1d5 con nivel (p.ej. “Principiante”), totalWeeks: 8 y startConfig (con/sin sábados).
Backend:
Usa hipertrofia_v2_session_config para definir D1‑D5 (muscle_groups, multiarticular_count, unilateral_count, analitico_count, default_sets, default_reps_range, default_rir_target, intensity_percentage, is_heavy_day).
Selecciona ejercicios concretos por tipo y grupo desde Ejercicios_Hipertrofia, y ordena por orden_recomendado → se respeta Multi/Uni/Analítico y el patrón de la lámina de “Estructura de la sesión”.
Script validate-volume-distribution.js garantiza que el volumen semanal por Pecho/Espalda/Piernas/Hombros/Bíceps/Tríceps/Core cae en los intervalos del PDF (“Volumen de Entrenamiento – MindFeed v1.0”).
El plan se guarda en methodology_plans con 40 sesiones (D1‑D5 × 8 semanas) y con un mapeo dinámico D1‑D5→días de la semana según el documento MAPEO_D1_D5_HIPERTROFIA_V2.md y el modal de sábados.
Coherencia:
Sí coincide en: estructura D1‑D5, frecuencia 2 por músculo, mezcla de tipos, intensidades relativas pesado/ligero, uso de RIR, volumen objetivo.
Diferencia importante: el motor actual fija el bloque en 40 sesiones (~8 semanas), mientras que la teoría habla de 10–12 semanas + semana 0. Esto está reconocido en tu propio resumen como “Extender a 10–12 semanas – pendiente”.
Ejecución de sesiones, progresión y deload
Teoría (bloque principiante + flags):
Progresión +2,5 % semanal si mean_RIR ≥3 y sin fatiga.
Deload automático semana 6 o si aparecen suficientes flags críticos.
Penalización por solapamiento neural alto (reducción de carga).
Código:
Cada serie se registra vía /api/hipertrofiav2/save-set en hypertrophy_set_logs (incluye rir_reported).
Tras sesión o microciclo, el frontend puede llamar a:
/apply-progression → app.apply_microcycle_progression aplica el +2,5 %.
/detect-auto-fatigue + /fatigue-status + /apply-fatigue-adjustments para los flags de fatiga, con tabla fatigue_flags.
/check-neural-overlap → app.detect_neural_overlap detecta patrones repetidos (Press vs Press, RDL vs movimientos similares, etc.).
/check-deload y /activate-deload ajustan cargas −30 % y volumen −50 %.
Además, el sistema unificado de rutinas (IMPLEMENTATION_COMPLETE.md) se encarga de estados de sesión, histórico y plan activo.
Coherencia: La cadena RIR → fatiga → solapamiento → progresión/deload está implementada de forma muy alineada con el pseudocódigo del documento de “Flags de fatiga / lógica IA”.
3. Gaps detectados y recomendaciones

Te resumo los puntos donde teoría y app no están todavía 1:1 o pueden refinarse:

Duración del bloque de hipertrofia

Teoría: 10–12 semanas + semana 0 de calibración.
Código: D1‑D5 se repite actualmente totalWeeks (frontend usa por defecto 8 semanas para 40 sesiones).
Recomendación:
Parametrizar totalWeeks por nivel (p.ej. 10 para principiantes, 12 avanzados) y exponerlo en la UI.
Implementar explícitamente la “semana 0” con menor intensidad (p.ej. 70 % 1RM) antes de entrar en el ciclo estándar.
Series de aproximación (warm‑up modal)

Teoría: documento de “Series de aproximación – Implementación Modal” con porcentajes 40–60–70 %.
Código: el modal está documentado pero no veo integración directa en el flujo de HipertrofiaV2 (tu propio resumen lo marca como pendiente).
Recomendación:
Conectar el modal a RoutineSessionModal.jsx antes de las series efectivas de ejercicios de hipertrofia.
Marcar estas series como is_warmup en hypertrophy_set_logs para que no cuenten como volumen efectivo.
Ajustes por sexo en descansos

Teoría: en la fase de hipertrofia las mujeres podrían usar descansos un 15–20 % más cortos según tipo de ejercicio.
Código: los descansos por ejercicio vienen de Ejercicios_Hipertrofia.descanso_seg y se usan igual para todos; no hay lógica sex‑aware.
Recomendación:
Añadir un pequeño ajuste en backend o frontend (p.ej. rest_seconds *= 0.85 para mujeres en uni/analítico) o pre‑calcularlo en la plantilla de sesión.
Extensión de prioridad muscular

Teoría: módulo de prioridad con top sets extra para un músculo y congelación de progresión en no prioritarios.
Código: ya existen endpoints (/activate-priority, /priority-status) y funciones SQL (activate_muscle_priority, check_priority_timeout, etc.), pero falta verlos plenamente explotados en la UI (tu resumen lo etiqueta como “Prioridad Muscular Completa – pendiente”).
Recomendación:
Añadir un flujo claro en frontend para elegir músculo prioritario (ej. desde la pantalla de progreso) y visualizar el impacto (top sets marcados, avisos en sesión).
Re‑evaluación automática del nivel

Teoría sugiere reevaluar progresión/abandono y poder subir/bajar nivel.
Código: el especialista de hipertrofia es un endpoint manual; no hay job o trigger que re‑llame al modelo según performance.
Recomendación:
Definir una regla (ej. tras completar N microciclos o si hay muchas sesiones “missed”) que dispare una nueva evaluación y sugiera cambiar a intermedio o volver a adaptación.
Experiencia de usuario en el bloque de adaptación

Lógica backend muy sólida, pero la UX puede ser más guiada: ahora el usuario puede crear bloque, ver badge y transicionar, pero no está claro si la app “empuja” siempre a los perfiles correctos por ese camino.
Recomendación:
Desde HipertrofiaV2ManualCard, forzar adaptación como paso obligatorio cuando el perfil devuelva tags de novato/reeadaptación (en vez de dejarlo opcional).
Mostrar un resumen muy simple al usuario: “Estás en semana 2/3 de adaptación; al cumplir estos 4 criterios pasas automáticamente al bloque D1‑D5”.
Homogeneidad entre generadores “viejos” y MindFeed

hipertrofiaPlanGenerator.js maneja aún un esquema de 3–5 días/semana distinto del D1‑D5.
Recomendación:
Mantener HipertrofiaV2 como camino principal para hipertrofia guiada y, si el generador antiguo sigue expuesto, aclarar en UI que es un modo alternativo o simplificado para no mezclar reglas.
4. Resumen accionable

A nivel de modelo de entrenamiento, tu app ya hace lo importante: adapta principiantes, controla RIR y fatiga, respeta volumen y estructura D1‑D5, y automatiza progresión/deload según las reglas del PDF.
Las principales oportunidades de mejora están en: extender el bloque a 10–12 semanas con semana 0, implementar de verdad las series de aproximación, añadir ajustes por sexo en descansos, completar el módulo de prioridad muscular y hacer que el paso por adaptación sea totalmente guiado para perfiles novatos.